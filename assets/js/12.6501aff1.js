(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{558:function(t,v,_){"use strict";_.r(v);var r=_(9),s=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"计算机网络"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("网络参考模型")])])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("OSI网络参考模型")]),t._v(" "),_("th",[t._v("协议")]),t._v(" "),_("th",[t._v("TCP/IP")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("7 应用层")]),t._v(" "),_("td",[t._v("DNS、HTTP、SSH、FTP、SMTP...")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("6 表示层")]),t._v(" "),_("td",[t._v("...")]),t._v(" "),_("td",[t._v("5 应用层")])]),t._v(" "),_("tr",[_("td",[t._v("5 会话层")]),t._v(" "),_("td",[t._v("...")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("4 传输层")]),t._v(" "),_("td",[t._v("TCP、UDP、SCTP")]),t._v(" "),_("td",[t._v("4 传输层")])]),t._v(" "),_("tr",[_("td",[t._v("3 网络层")]),t._v(" "),_("td",[t._v("IPv4、IPv6、ARP、ICMP")]),t._v(" "),_("td",[t._v("3 网络层")])]),t._v(" "),_("tr",[_("td",[t._v("2 数据链路层")]),t._v(" "),_("td",[t._v("以太网、无线LAN")]),t._v(" "),_("td",[t._v("2 数据链路层")])]),t._v(" "),_("tr",[_("td",[t._v("1 物理层")]),t._v(" "),_("td",[t._v("光纤、双绞线电缆、无线设备")]),t._v(" "),_("td",[t._v("1 物理层")])])])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("strong",[t._v("什么是HTTP协议？")])])]),t._v(" "),_("p",[t._v("HTTP协议中文名是超文本传输协议，是一种无状态的，以请求、应答的方式运行的协议。是互联网上应用最广泛的一种网络协议。")]),t._v(" "),_("p",[t._v("优点：")]),t._v(" "),_("p",[t._v("1）灵活可扩展的；主要在两个方面，一个是语义上的自由，另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片，视频等任意数据。")]),t._v(" "),_("p",[t._v("2）可靠传输；HTTP基于TCP/IP，因此把着这一特性继承下来了。")]),t._v(" "),_("p",[t._v("3）请求-应答；也就是一发一收，有来有回。")]),t._v(" "),_("p",[t._v("4）无状态；每次http请求都是独立、无关的，默认不需要保留状态信息，在不需要保存连接上下文信息，无状态会减少网络开销，成为了http优点。")]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("p",[t._v("1）无状态；在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量的重复信息，这时候就是无状态的缺点了。")]),t._v(" "),_("p",[t._v("2）明文传输；即协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式")]),t._v(" "),_("p",[t._v("3）对头阻塞问题；当http开启长连接的时，共用一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长的话，其他请求就处于阻塞状态。")]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("strong",[t._v("https协议是什么？")])])]),t._v(" "),_("p",[t._v("是以安全为目标的http通道，简单的来说就http的安全版，即http下加入SSL层，https的安全基础就是SSL。")]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[_("strong",[t._v("http和https的区别是什么？")])])]),t._v(" "),_("p",[t._v("http传输的数据都是未加密的，也就是明文传输，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，比http协议的安全性更高。")]),t._v(" "),_("p",[t._v("主要区别如下：")]),t._v(" "),_("ul",[_("li",[t._v("https协议需要ca证书，费用较高。")]),t._v(" "),_("li",[t._v("http的信息是明文传输的，https则更具有安全性的SSL加密传输协议。")]),t._v(" "),_("li",[t._v("使用不同的连接方式，端口也不同，一般，http协议的端口为80，https的端口为443。")]),t._v(" "),_("li",[t._v("http连接很简单，是无状态的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")])]),t._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[_("strong",[t._v("简述一下TCP三次握手")])])]),t._v(" "),_("p",[t._v("第一次握手：客户端发送报文段，服务端只可以确认自己可以接受客户端发送的报文段；")]),t._v(" "),_("p",[t._v("第二次握手：客户端可以确认服务端收到了自己发送的报文段，并且可以确认自己可以接受服务端发送的报文段；")]),t._v(" "),_("p",[t._v("第三次握手：服务端可以确认客户端收到了自己发送的报文段；")]),t._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[_("strong",[t._v("TCP和UDP的区别？")])])]),t._v(" "),_("ul",[_("li",[t._v("TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。")]),t._v(" "),_("li",[t._v("TCP提供可靠的服务；也就是说通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大的努力交付，即不保证可靠交付。")]),t._v(" "),_("li",[t._v("TCP是面向字节流的，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此可能会出现丢包，对实时的应用比如电话、视频会议等）")]),t._v(" "),_("li",[t._v("TCP只能一对一，而UDP支持一对一，一对多等。")]),t._v(" "),_("li",[t._v("TCP的首部较大，为20字节；而UDP只有8字节。")]),t._v(" "),_("li",[t._v("TCP是面向连接的可靠性传输，而UDP是不可靠的。")])]),t._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[_("strong",[t._v("说一下http2.0")])])]),t._v(" "),_("p",[t._v("http2.0基于1999年发布的http1.0之后的首次更新；内容安全，因为http2.0是基于https；提升了访问速度（相比http1.0，请求资源所需时间更少，访问速度更快）；允许多路复用，可同时通过单一的http/2连接发送多重请求-响应信息。改善了：在http1.1中 ，队头阻塞问题；二进制分帧：http2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码、首部压缩、服务端推送等。")]),t._v(" "),_("ol",{attrs:{start:"8"}},[_("li",[_("strong",[t._v("GET和POST的区别")])])]),t._v(" "),_("ul",[_("li",[t._v("get参数通过url传递，post参数是放在请求体里")]),t._v(" "),_("li",[t._v("get的请求参数是有长度限制的，而post没有")]),t._v(" "),_("li",[t._v("get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息")]),t._v(" "),_("li",[t._v("get请求只能进行url编码，而post支持多种编码方式")]),t._v(" "),_("li",[t._v("get请求浏览器会主动缓存，而post需要手动设置")]),t._v(" "),_("li",[t._v("get产生一个TCP数据包；post产生两个TCP数据包")])]),t._v(" "),_("ol",{attrs:{start:"9"}},[_("li",[_("strong",[t._v("XSS和CSRF的网络攻击及防范")])])]),t._v(" "),_("p",[_("strong",[t._v("CSRF")]),t._v("：跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。防御方式的话：使用验证码，检查 https 头部的 refer，使用 token")]),t._v(" "),_("p",[_("strong",[t._v("XSS")]),t._v("：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻 击，比如获取 cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御的话为cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。")]),t._v(" "),_("ol",{attrs:{start:"10"}},[_("li",[_("p",[_("strong",[t._v("从输入")]),t._v(" "),_("strong",[t._v("URL")]),t._v(" "),_("strong",[t._v("到页面加载的全过程")])])]),t._v(" "),_("li",[_("p",[t._v("浏览器获取用户输入，等待 url 输入完毕，触发 enter 事件；")])]),t._v(" "),_("li",[_("p",[t._v("解析 URL，分析协议头，再分析主机名是域名还是 IP 地址；")])]),t._v(" "),_("li",[_("p",[t._v("如果主机名是域名的话，则发送一个 DNS 查询请求到 DNS 服务器，获")])])]),t._v(" "),_("p",[t._v("得主机 IP 地址；")]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("使 用 DNS 获 取 到 主 机 IP 地 址 后 ， 向 目 的 地 址 发 送 一 个")])]),t._v(" "),_("p",[t._v("（http/https/protocol）请求，并且在网络套接字上自动添加端口信息")]),t._v(" "),_("p",[t._v("（http 80 https 443）；")]),t._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[_("p",[t._v("等待服务器响应结果；")])]),t._v(" "),_("li",[_("p",[t._v("将响应结果（html）经浏览器引擎解析后得到 Render tree，浏览器将 Render")])])]),t._v(" "),_("p",[t._v("tree 进行渲染后显示在显示器中，用户此时可以看到页面被渲染。")]),t._v(" "),_("h2",{attrs:{id:"浏览器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),_("ol",[_("li",[t._v("说一下浏览器缓存")])]),t._v(" "),_("p",[_("img",{attrs:{src:t.$withBase("/interview/01.png")}})]),t._v(" "),_("p",[t._v("浏览器缓存主要分为强"),_("strong",[t._v("强缓存")]),t._v("（也称"),_("strong",[t._v("本地缓存")]),t._v("）和"),_("strong",[t._v("协商缓存")]),t._v("（也称"),_("strong",[t._v("弱缓存")]),t._v("）。根据上图，浏览器在第一次请求发生后，再次发送请求时：")]),t._v(" "),_("ul",[_("li",[t._v("浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的"),_("code",[t._v("Cache-Control")]),t._v("和"),_("code",[t._v("Expires")]),t._v("来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。")]),t._v(" "),_("li",[t._v("如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过"),_("code",[t._v("If-None-Match")]),t._v("头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将"),_("code",[t._v("If-None-Match")]),t._v("的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将"),_("code",[t._v("If-None-Match")]),t._v("的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过"),_("code",[t._v("If-Modified-Since")]),t._v("头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。")])]),t._v(" "),_("h2",{attrs:{id:"event-loop-及异步机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-及异步机制"}},[t._v("#")]),t._v(" Event Loop 及异步机制")]),t._v(" "),_("p",[t._v("同步任务会在主线程中优先执行；如果遇到异步任务，在异步任务队列中的队列分为两种类型：宏任务（macro-task）和微任务（micro-task）；执行顺序为：首先会执行宏任务队列的对头任务，执行完毕后，再执行微任务队列里的所有任务，执行完毕后会清空微任务中的任务，接着执行宏任务队列中的第二个任务，依次循环。")])])}),[],!1,null,null,null);v.default=s.exports}}]);